// Autogenerated from Pigeon (v26.0.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation

#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif

/// Error class for passing custom error details to Dart side.
final class PigeonError: Error {
  let code: String
  let message: String?
  let details: Sendable?

  init(code: String, message: String?, details: Sendable?) {
    self.code = code
    self.message = message
    self.details = details
  }

  var localizedDescription: String {
    return
      "PigeonError(code: \(code), message: \(message ?? "<nil>"), details: \(details ?? "<nil>")"
  }
}

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let pigeonError = error as? PigeonError {
    return [
      pigeonError.code,
      pigeonError.message,
      pigeonError.details,
    ]
  }
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

func deepEqualsMessages(_ lhs: Any?, _ rhs: Any?) -> Bool {
  let cleanLhs = nilOrValue(lhs) as Any?
  let cleanRhs = nilOrValue(rhs) as Any?
  switch (cleanLhs, cleanRhs) {
  case (nil, nil):
    return true

  case (nil, _), (_, nil):
    return false

  case is (Void, Void):
    return true

  case let (cleanLhsHashable, cleanRhsHashable) as (AnyHashable, AnyHashable):
    return cleanLhsHashable == cleanRhsHashable

  case let (cleanLhsArray, cleanRhsArray) as ([Any?], [Any?]):
    guard cleanLhsArray.count == cleanRhsArray.count else { return false }
    for (index, element) in cleanLhsArray.enumerated() {
      if !deepEqualsMessages(element, cleanRhsArray[index]) {
        return false
      }
    }
    return true

  case let (cleanLhsDictionary, cleanRhsDictionary) as ([AnyHashable: Any?], [AnyHashable: Any?]):
    guard cleanLhsDictionary.count == cleanRhsDictionary.count else { return false }
    for (key, cleanLhsValue) in cleanLhsDictionary {
      guard cleanRhsDictionary.index(forKey: key) != nil else { return false }
      if !deepEqualsMessages(cleanLhsValue, cleanRhsDictionary[key]!) {
        return false
      }
    }
    return true

  default:
    // Any other type shouldn't be able to be used with pigeon. File an issue if you find this to be untrue.
    return false
  }
}

func deepHashMessages(value: Any?, hasher: inout Hasher) {
  if let valueList = value as? [AnyHashable] {
     for item in valueList { deepHashMessages(value: item, hasher: &hasher) }
     return
  }

  if let valueDict = value as? [AnyHashable: AnyHashable] {
    for key in valueDict.keys { 
      hasher.combine(key)
      deepHashMessages(value: valueDict[key]!, hasher: &hasher)
    }
    return
  }

  if let hashableValue = value as? AnyHashable {
    hasher.combine(hashableValue.hashValue)
  }

  return hasher.combine(String(describing: value))
}

    

/// Predefined error types for consistent error handling across platforms
enum PasskeyErrorType: Int {
  case invalidParameters = 0
  case missingRequiredField = 1
  case invalidFormat = 2
  case decodingChallenge = 3
  case userCancelled = 4
  case userTimeout = 5
  case userOptedOut = 6
  case insufficientPermissions = 7
  case securityViolation = 8
  case notAllowed = 9
  case domainNotAssociated = 10
  case noCredentialsAvailable = 11
  case credentialNotFound = 12
  case invalidCredential = 13
  case credentialAlreadyExists = 14
  case invalidResponse = 15
  case notHandled = 16
  case failed = 17
  case platformNotSupported = 18
  case operationNotSupported = 19
  case systemError = 20
  case networkError = 21
  case domError = 22
  case webauthnError = 23
  case attestationError = 24
  case excludeCredentialsMatch = 25
  case unexpectedAuthorizationResponse = 26
  case wkErrorDomain = 27
  case unknownError = 28
  case unexpectedError = 29
}

/// Represents a standardized passkey exception that can be thrown across platforms
///
/// Generated class from Pigeon that represents data sent in messages.
struct PasskeyException: Hashable {
  /// Error type identifying the specific type of error
  var errorType: PasskeyErrorType
  /// Error message describing what went wrong
  var message: String
  /// Optional additional details about the error
  var details: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> PasskeyException? {
    let errorType = pigeonVar_list[0] as! PasskeyErrorType
    let message = pigeonVar_list[1] as! String
    let details = pigeonVar_list[2] as! String

    return PasskeyException(
      errorType: errorType,
      message: message,
      details: details
    )
  }
  func toList() -> [Any?] {
    return [
      errorType,
      message,
      details,
    ]
  }
  static func == (lhs: PasskeyException, rhs: PasskeyException) -> Bool {
    return deepEqualsMessages(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashMessages(value: toList(), hasher: &hasher)
  }
}

/// Represents the response data for authentication generation options
///
/// Generated class from Pigeon that represents data sent in messages.
struct AuthGenerateOptionResponseData: Hashable {
  /// The relying party identifier
  var rpId: String
  /// The challenge string
  var challenge: String
  /// List of allowed credentials
  var allowCredentials: [AuthGenerateOptionAllowCredential]
  /// Timeout value in milliseconds
  var timeout: Int64
  /// User verification requirement
  var userVerification: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> AuthGenerateOptionResponseData? {
    let rpId = pigeonVar_list[0] as! String
    let challenge = pigeonVar_list[1] as! String
    let allowCredentials = pigeonVar_list[2] as! [AuthGenerateOptionAllowCredential]
    let timeout = pigeonVar_list[3] as! Int64
    let userVerification = pigeonVar_list[4] as! String

    return AuthGenerateOptionResponseData(
      rpId: rpId,
      challenge: challenge,
      allowCredentials: allowCredentials,
      timeout: timeout,
      userVerification: userVerification
    )
  }
  func toList() -> [Any?] {
    return [
      rpId,
      challenge,
      allowCredentials,
      timeout,
      userVerification,
    ]
  }
  static func == (lhs: AuthGenerateOptionResponseData, rhs: AuthGenerateOptionResponseData) -> Bool {
    return deepEqualsMessages(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashMessages(value: toList(), hasher: &hasher)
  }
}

/// Represents an allowed credential for authentication
///
/// Generated class from Pigeon that represents data sent in messages.
struct AuthGenerateOptionAllowCredential: Hashable {
  /// The credential identifier
  var id: String
  /// The credential type
  var type: String
  /// List of transport methods
  var transports: [String]


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> AuthGenerateOptionAllowCredential? {
    let id = pigeonVar_list[0] as! String
    let type = pigeonVar_list[1] as! String
    let transports = pigeonVar_list[2] as! [String]

    return AuthGenerateOptionAllowCredential(
      id: id,
      type: type,
      transports: transports
    )
  }
  func toList() -> [Any?] {
    return [
      id,
      type,
      transports,
    ]
  }
  static func == (lhs: AuthGenerateOptionAllowCredential, rhs: AuthGenerateOptionAllowCredential) -> Bool {
    return deepEqualsMessages(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashMessages(value: toList(), hasher: &hasher)
  }
}

/// Represents the response data for authentication verification
///
/// Generated class from Pigeon that represents data sent in messages.
struct AuthVerifyResponse: Hashable {
  /// Whether the authentication was verified
  var verified: Bool
  /// Access token for authenticated session
  var accessToken: String
  /// User information (optional)
  var user: User? = nil
  /// Refresh token for session renewal
  var refreshToken: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> AuthVerifyResponse? {
    let verified = pigeonVar_list[0] as! Bool
    let accessToken = pigeonVar_list[1] as! String
    let user: User? = nilOrValue(pigeonVar_list[2])
    let refreshToken = pigeonVar_list[3] as! String

    return AuthVerifyResponse(
      verified: verified,
      accessToken: accessToken,
      user: user,
      refreshToken: refreshToken
    )
  }
  func toList() -> [Any?] {
    return [
      verified,
      accessToken,
      user,
      refreshToken,
    ]
  }
  static func == (lhs: AuthVerifyResponse, rhs: AuthVerifyResponse) -> Bool {
    return deepEqualsMessages(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashMessages(value: toList(), hasher: &hasher)
  }
}

/// Represents user information
///
/// Generated class from Pigeon that represents data sent in messages.
struct User: Hashable {
  /// User identifier
  var id: String
  /// Username
  var username: String
  /// Phone number (optional)
  var phone: String? = nil
  /// Email address (optional)
  var email: String? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> User? {
    let id = pigeonVar_list[0] as! String
    let username = pigeonVar_list[1] as! String
    let phone: String? = nilOrValue(pigeonVar_list[2])
    let email: String? = nilOrValue(pigeonVar_list[3])

    return User(
      id: id,
      username: username,
      phone: phone,
      email: email
    )
  }
  func toList() -> [Any?] {
    return [
      id,
      username,
      phone,
      email,
    ]
  }
  static func == (lhs: User, rhs: User) -> Bool {
    return deepEqualsMessages(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashMessages(value: toList(), hasher: &hasher)
  }
}

/// Represents the response data for creating a passkey
///
/// Generated class from Pigeon that represents data sent in messages.
struct CreatePasskeyResponseData: Hashable {
  /// Raw identifier
  var rawId: String
  /// Authenticator attachment type
  var authenticatorAttachment: String
  /// Type of credential
  var type: String
  /// Credential identifier
  var id: String
  /// Response data from passkey creation
  var response: CreatePasskeyResponse
  /// Client extension results
  var clientExtensionResults: CreatePasskeyExtension
  /// Username associated with the passkey
  var username: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> CreatePasskeyResponseData? {
    let rawId = pigeonVar_list[0] as! String
    let authenticatorAttachment = pigeonVar_list[1] as! String
    let type = pigeonVar_list[2] as! String
    let id = pigeonVar_list[3] as! String
    let response = pigeonVar_list[4] as! CreatePasskeyResponse
    let clientExtensionResults = pigeonVar_list[5] as! CreatePasskeyExtension
    let username = pigeonVar_list[6] as! String

    return CreatePasskeyResponseData(
      rawId: rawId,
      authenticatorAttachment: authenticatorAttachment,
      type: type,
      id: id,
      response: response,
      clientExtensionResults: clientExtensionResults,
      username: username
    )
  }
  func toList() -> [Any?] {
    return [
      rawId,
      authenticatorAttachment,
      type,
      id,
      response,
      clientExtensionResults,
      username,
    ]
  }
  static func == (lhs: CreatePasskeyResponseData, rhs: CreatePasskeyResponseData) -> Bool {
    return deepEqualsMessages(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashMessages(value: toList(), hasher: &hasher)
  }
}

/// Represents the response from passkey creation
///
/// Generated class from Pigeon that represents data sent in messages.
struct CreatePasskeyResponse: Hashable {
  /// Client data JSON
  var clientDataJSON: String
  /// Attestation object
  var attestationObject: String
  /// List of transport methods
  var transports: [String]
  /// Authenticator data
  var authenticatorData: String
  /// Public key algorithm identifier
  var publicKeyAlgorithm: Int64
  /// Public key
  var publicKey: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> CreatePasskeyResponse? {
    let clientDataJSON = pigeonVar_list[0] as! String
    let attestationObject = pigeonVar_list[1] as! String
    let transports = pigeonVar_list[2] as! [String]
    let authenticatorData = pigeonVar_list[3] as! String
    let publicKeyAlgorithm = pigeonVar_list[4] as! Int64
    let publicKey = pigeonVar_list[5] as! String

    return CreatePasskeyResponse(
      clientDataJSON: clientDataJSON,
      attestationObject: attestationObject,
      transports: transports,
      authenticatorData: authenticatorData,
      publicKeyAlgorithm: publicKeyAlgorithm,
      publicKey: publicKey
    )
  }
  func toList() -> [Any?] {
    return [
      clientDataJSON,
      attestationObject,
      transports,
      authenticatorData,
      publicKeyAlgorithm,
      publicKey,
    ]
  }
  static func == (lhs: CreatePasskeyResponse, rhs: CreatePasskeyResponse) -> Bool {
    return deepEqualsMessages(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashMessages(value: toList(), hasher: &hasher)
  }
}

/// Represents client extension results for passkey creation
///
/// Generated class from Pigeon that represents data sent in messages.
struct CreatePasskeyExtension: Hashable {
  /// Credential properties extension (optional)
  var credProps: CreatePasskeyExtensionProps? = nil
  /// PRF extension (optional)
  var prf: CreatePasskeyExtensionPrf? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> CreatePasskeyExtension? {
    let credProps: CreatePasskeyExtensionProps? = nilOrValue(pigeonVar_list[0])
    let prf: CreatePasskeyExtensionPrf? = nilOrValue(pigeonVar_list[1])

    return CreatePasskeyExtension(
      credProps: credProps,
      prf: prf
    )
  }
  func toList() -> [Any?] {
    return [
      credProps,
      prf,
    ]
  }
  static func == (lhs: CreatePasskeyExtension, rhs: CreatePasskeyExtension) -> Bool {
    return deepEqualsMessages(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashMessages(value: toList(), hasher: &hasher)
  }
}

/// Represents PRF extension properties
///
/// Generated class from Pigeon that represents data sent in messages.
struct CreatePasskeyExtensionPrf: Hashable {
  /// Enabled flag
  var rk: Bool


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> CreatePasskeyExtensionPrf? {
    let rk = pigeonVar_list[0] as! Bool

    return CreatePasskeyExtensionPrf(
      rk: rk
    )
  }
  func toList() -> [Any?] {
    return [
      rk
    ]
  }
  static func == (lhs: CreatePasskeyExtensionPrf, rhs: CreatePasskeyExtensionPrf) -> Bool {
    return deepEqualsMessages(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashMessages(value: toList(), hasher: &hasher)
  }
}

/// Represents credential properties extension
///
/// Generated class from Pigeon that represents data sent in messages.
struct CreatePasskeyExtensionProps: Hashable {
  /// Resident key flag
  var rk: Bool


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> CreatePasskeyExtensionProps? {
    let rk = pigeonVar_list[0] as! Bool

    return CreatePasskeyExtensionProps(
      rk: rk
    )
  }
  func toList() -> [Any?] {
    return [
      rk
    ]
  }
  static func == (lhs: CreatePasskeyExtensionProps, rhs: CreatePasskeyExtensionProps) -> Bool {
    return deepEqualsMessages(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashMessages(value: toList(), hasher: &hasher)
  }
}

/// Represents the response data for passkey authentication
///
/// Generated class from Pigeon that represents data sent in messages.
struct GetPasskeyAuthenticationResponseData: Hashable {
  /// Authenticator attachment type
  var authenticatorAttachment: String
  /// Credential identifier
  var id: String
  /// Raw identifier
  var rawId: String
  /// Authentication response data
  var response: GetPasskeyAuthenticationResponse
  /// Type of credential
  var type: String
  /// Username associated with the passkey
  var username: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> GetPasskeyAuthenticationResponseData? {
    let authenticatorAttachment = pigeonVar_list[0] as! String
    let id = pigeonVar_list[1] as! String
    let rawId = pigeonVar_list[2] as! String
    let response = pigeonVar_list[3] as! GetPasskeyAuthenticationResponse
    let type = pigeonVar_list[4] as! String
    let username = pigeonVar_list[5] as! String

    return GetPasskeyAuthenticationResponseData(
      authenticatorAttachment: authenticatorAttachment,
      id: id,
      rawId: rawId,
      response: response,
      type: type,
      username: username
    )
  }
  func toList() -> [Any?] {
    return [
      authenticatorAttachment,
      id,
      rawId,
      response,
      type,
      username,
    ]
  }
  static func == (lhs: GetPasskeyAuthenticationResponseData, rhs: GetPasskeyAuthenticationResponseData) -> Bool {
    return deepEqualsMessages(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashMessages(value: toList(), hasher: &hasher)
  }
}

/// Represents the authentication response from passkey
///
/// Generated class from Pigeon that represents data sent in messages.
struct GetPasskeyAuthenticationResponse: Hashable {
  /// Client data JSON
  var clientDataJSON: String
  /// Authenticator data
  var authenticatorData: String
  /// Digital signature
  var signature: String
  /// User handle
  var userHandle: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> GetPasskeyAuthenticationResponse? {
    let clientDataJSON = pigeonVar_list[0] as! String
    let authenticatorData = pigeonVar_list[1] as! String
    let signature = pigeonVar_list[2] as! String
    let userHandle = pigeonVar_list[3] as! String

    return GetPasskeyAuthenticationResponse(
      clientDataJSON: clientDataJSON,
      authenticatorData: authenticatorData,
      signature: signature,
      userHandle: userHandle
    )
  }
  func toList() -> [Any?] {
    return [
      clientDataJSON,
      authenticatorData,
      signature,
      userHandle,
    ]
  }
  static func == (lhs: GetPasskeyAuthenticationResponse, rhs: GetPasskeyAuthenticationResponse) -> Bool {
    return deepEqualsMessages(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashMessages(value: toList(), hasher: &hasher)
  }
}

/// Represents the data for generating registration options
///
/// Generated class from Pigeon that represents data sent in messages.
struct RegisterGenerateOptionData: Hashable {
  /// Challenge string
  var challenge: String
  /// Relying party information
  var rp: RegisterGenerateOptionRp
  /// User information
  var user: RegisterGenerateOptionUser
  /// Public key credential parameters
  var pubKeyCredParams: [RegisterGenerateOptionPublicKeyParams]
  /// Timeout value in milliseconds
  var timeout: Int64
  /// Attestation preference
  var attestation: String
  /// Credentials to exclude from registration
  var excludeCredentials: [RegisterGenerateOptionExcludeCredential]
  /// Authenticator selection criteria
  var authenticatorSelection: RegisterGenerateOptionAuthenticatorSelection
  /// Extensions for registration
  var extensions: RegisterGenerateOptionExtension


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> RegisterGenerateOptionData? {
    let challenge = pigeonVar_list[0] as! String
    let rp = pigeonVar_list[1] as! RegisterGenerateOptionRp
    let user = pigeonVar_list[2] as! RegisterGenerateOptionUser
    let pubKeyCredParams = pigeonVar_list[3] as! [RegisterGenerateOptionPublicKeyParams]
    let timeout = pigeonVar_list[4] as! Int64
    let attestation = pigeonVar_list[5] as! String
    let excludeCredentials = pigeonVar_list[6] as! [RegisterGenerateOptionExcludeCredential]
    let authenticatorSelection = pigeonVar_list[7] as! RegisterGenerateOptionAuthenticatorSelection
    let extensions = pigeonVar_list[8] as! RegisterGenerateOptionExtension

    return RegisterGenerateOptionData(
      challenge: challenge,
      rp: rp,
      user: user,
      pubKeyCredParams: pubKeyCredParams,
      timeout: timeout,
      attestation: attestation,
      excludeCredentials: excludeCredentials,
      authenticatorSelection: authenticatorSelection,
      extensions: extensions
    )
  }
  func toList() -> [Any?] {
    return [
      challenge,
      rp,
      user,
      pubKeyCredParams,
      timeout,
      attestation,
      excludeCredentials,
      authenticatorSelection,
      extensions,
    ]
  }
  static func == (lhs: RegisterGenerateOptionData, rhs: RegisterGenerateOptionData) -> Bool {
    return deepEqualsMessages(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashMessages(value: toList(), hasher: &hasher)
  }
}

/// Represents a credential to exclude from registration
///
/// Generated class from Pigeon that represents data sent in messages.
struct RegisterGenerateOptionExcludeCredential: Hashable {
  /// Credential identifier
  var id: String
  /// Credential type
  var type: String
  /// List of transport methods
  var transports: [String]


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> RegisterGenerateOptionExcludeCredential? {
    let id = pigeonVar_list[0] as! String
    let type = pigeonVar_list[1] as! String
    let transports = pigeonVar_list[2] as! [String]

    return RegisterGenerateOptionExcludeCredential(
      id: id,
      type: type,
      transports: transports
    )
  }
  func toList() -> [Any?] {
    return [
      id,
      type,
      transports,
    ]
  }
  static func == (lhs: RegisterGenerateOptionExcludeCredential, rhs: RegisterGenerateOptionExcludeCredential) -> Bool {
    return deepEqualsMessages(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashMessages(value: toList(), hasher: &hasher)
  }
}

/// Represents relying party information for registration
///
/// Generated class from Pigeon that represents data sent in messages.
struct RegisterGenerateOptionRp: Hashable {
  /// Relying party name
  var name: String
  /// Relying party identifier
  var id: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> RegisterGenerateOptionRp? {
    let name = pigeonVar_list[0] as! String
    let id = pigeonVar_list[1] as! String

    return RegisterGenerateOptionRp(
      name: name,
      id: id
    )
  }
  func toList() -> [Any?] {
    return [
      name,
      id,
    ]
  }
  static func == (lhs: RegisterGenerateOptionRp, rhs: RegisterGenerateOptionRp) -> Bool {
    return deepEqualsMessages(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashMessages(value: toList(), hasher: &hasher)
  }
}

/// Represents user information for registration
///
/// Generated class from Pigeon that represents data sent in messages.
struct RegisterGenerateOptionUser: Hashable {
  /// User identifier
  var id: String
  /// User name
  var name: String
  /// Display name (defaults to empty string)
  var displayName: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> RegisterGenerateOptionUser? {
    let id = pigeonVar_list[0] as! String
    let name = pigeonVar_list[1] as! String
    let displayName = pigeonVar_list[2] as! String

    return RegisterGenerateOptionUser(
      id: id,
      name: name,
      displayName: displayName
    )
  }
  func toList() -> [Any?] {
    return [
      id,
      name,
      displayName,
    ]
  }
  static func == (lhs: RegisterGenerateOptionUser, rhs: RegisterGenerateOptionUser) -> Bool {
    return deepEqualsMessages(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashMessages(value: toList(), hasher: &hasher)
  }
}

/// Represents public key credential parameters
///
/// Generated class from Pigeon that represents data sent in messages.
struct RegisterGenerateOptionPublicKeyParams: Hashable {
  /// Algorithm identifier
  var alg: Int64
  /// Credential type
  var type: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> RegisterGenerateOptionPublicKeyParams? {
    let alg = pigeonVar_list[0] as! Int64
    let type = pigeonVar_list[1] as! String

    return RegisterGenerateOptionPublicKeyParams(
      alg: alg,
      type: type
    )
  }
  func toList() -> [Any?] {
    return [
      alg,
      type,
    ]
  }
  static func == (lhs: RegisterGenerateOptionPublicKeyParams, rhs: RegisterGenerateOptionPublicKeyParams) -> Bool {
    return deepEqualsMessages(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashMessages(value: toList(), hasher: &hasher)
  }
}

/// Represents authenticator selection criteria
///
/// Generated class from Pigeon that represents data sent in messages.
struct RegisterGenerateOptionAuthenticatorSelection: Hashable {
  /// Resident key requirement
  var residentKey: String
  /// User verification requirement
  var userVerification: String
  /// Whether resident key is required
  var requireResidentKey: Bool
  /// Authenticator attachment preference
  var authenticatorAttachment: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> RegisterGenerateOptionAuthenticatorSelection? {
    let residentKey = pigeonVar_list[0] as! String
    let userVerification = pigeonVar_list[1] as! String
    let requireResidentKey = pigeonVar_list[2] as! Bool
    let authenticatorAttachment = pigeonVar_list[3] as! String

    return RegisterGenerateOptionAuthenticatorSelection(
      residentKey: residentKey,
      userVerification: userVerification,
      requireResidentKey: requireResidentKey,
      authenticatorAttachment: authenticatorAttachment
    )
  }
  func toList() -> [Any?] {
    return [
      residentKey,
      userVerification,
      requireResidentKey,
      authenticatorAttachment,
    ]
  }
  static func == (lhs: RegisterGenerateOptionAuthenticatorSelection, rhs: RegisterGenerateOptionAuthenticatorSelection) -> Bool {
    return deepEqualsMessages(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashMessages(value: toList(), hasher: &hasher)
  }
}

/// Represents extensions for registration
///
/// Generated class from Pigeon that represents data sent in messages.
struct RegisterGenerateOptionExtension: Hashable {
  /// Credential properties extension
  var credProps: Bool


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> RegisterGenerateOptionExtension? {
    let credProps = pigeonVar_list[0] as! Bool

    return RegisterGenerateOptionExtension(
      credProps: credProps
    )
  }
  func toList() -> [Any?] {
    return [
      credProps
    ]
  }
  static func == (lhs: RegisterGenerateOptionExtension, rhs: RegisterGenerateOptionExtension) -> Bool {
    return deepEqualsMessages(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashMessages(value: toList(), hasher: &hasher)
  }
}

/// Represents the response data for registration verification
///
/// Generated class from Pigeon that represents data sent in messages.
struct RegisterVerifyResponse: Hashable {
  /// Whether the registration was verified
  var verified: Bool
  /// Access token for authenticated session
  var accessToken: String
  /// User information
  var user: User
  /// Refresh token for session renewal
  var refreshToken: String


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> RegisterVerifyResponse? {
    let verified = pigeonVar_list[0] as! Bool
    let accessToken = pigeonVar_list[1] as! String
    let user = pigeonVar_list[2] as! User
    let refreshToken = pigeonVar_list[3] as! String

    return RegisterVerifyResponse(
      verified: verified,
      accessToken: accessToken,
      user: user,
      refreshToken: refreshToken
    )
  }
  func toList() -> [Any?] {
    return [
      verified,
      accessToken,
      user,
      refreshToken,
    ]
  }
  static func == (lhs: RegisterVerifyResponse, rhs: RegisterVerifyResponse) -> Bool {
    return deepEqualsMessages(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashMessages(value: toList(), hasher: &hasher)
  }
}

private class MessagesPigeonCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 129:
      let enumResultAsInt: Int? = nilOrValue(self.readValue() as! Int?)
      if let enumResultAsInt = enumResultAsInt {
        return PasskeyErrorType(rawValue: enumResultAsInt)
      }
      return nil
    case 130:
      return PasskeyException.fromList(self.readValue() as! [Any?])
    case 131:
      return AuthGenerateOptionResponseData.fromList(self.readValue() as! [Any?])
    case 132:
      return AuthGenerateOptionAllowCredential.fromList(self.readValue() as! [Any?])
    case 133:
      return AuthVerifyResponse.fromList(self.readValue() as! [Any?])
    case 134:
      return User.fromList(self.readValue() as! [Any?])
    case 135:
      return CreatePasskeyResponseData.fromList(self.readValue() as! [Any?])
    case 136:
      return CreatePasskeyResponse.fromList(self.readValue() as! [Any?])
    case 137:
      return CreatePasskeyExtension.fromList(self.readValue() as! [Any?])
    case 138:
      return CreatePasskeyExtensionPrf.fromList(self.readValue() as! [Any?])
    case 139:
      return CreatePasskeyExtensionProps.fromList(self.readValue() as! [Any?])
    case 140:
      return GetPasskeyAuthenticationResponseData.fromList(self.readValue() as! [Any?])
    case 141:
      return GetPasskeyAuthenticationResponse.fromList(self.readValue() as! [Any?])
    case 142:
      return RegisterGenerateOptionData.fromList(self.readValue() as! [Any?])
    case 143:
      return RegisterGenerateOptionExcludeCredential.fromList(self.readValue() as! [Any?])
    case 144:
      return RegisterGenerateOptionRp.fromList(self.readValue() as! [Any?])
    case 145:
      return RegisterGenerateOptionUser.fromList(self.readValue() as! [Any?])
    case 146:
      return RegisterGenerateOptionPublicKeyParams.fromList(self.readValue() as! [Any?])
    case 147:
      return RegisterGenerateOptionAuthenticatorSelection.fromList(self.readValue() as! [Any?])
    case 148:
      return RegisterGenerateOptionExtension.fromList(self.readValue() as! [Any?])
    case 149:
      return RegisterVerifyResponse.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class MessagesPigeonCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? PasskeyErrorType {
      super.writeByte(129)
      super.writeValue(value.rawValue)
    } else if let value = value as? PasskeyException {
      super.writeByte(130)
      super.writeValue(value.toList())
    } else if let value = value as? AuthGenerateOptionResponseData {
      super.writeByte(131)
      super.writeValue(value.toList())
    } else if let value = value as? AuthGenerateOptionAllowCredential {
      super.writeByte(132)
      super.writeValue(value.toList())
    } else if let value = value as? AuthVerifyResponse {
      super.writeByte(133)
      super.writeValue(value.toList())
    } else if let value = value as? User {
      super.writeByte(134)
      super.writeValue(value.toList())
    } else if let value = value as? CreatePasskeyResponseData {
      super.writeByte(135)
      super.writeValue(value.toList())
    } else if let value = value as? CreatePasskeyResponse {
      super.writeByte(136)
      super.writeValue(value.toList())
    } else if let value = value as? CreatePasskeyExtension {
      super.writeByte(137)
      super.writeValue(value.toList())
    } else if let value = value as? CreatePasskeyExtensionPrf {
      super.writeByte(138)
      super.writeValue(value.toList())
    } else if let value = value as? CreatePasskeyExtensionProps {
      super.writeByte(139)
      super.writeValue(value.toList())
    } else if let value = value as? GetPasskeyAuthenticationResponseData {
      super.writeByte(140)
      super.writeValue(value.toList())
    } else if let value = value as? GetPasskeyAuthenticationResponse {
      super.writeByte(141)
      super.writeValue(value.toList())
    } else if let value = value as? RegisterGenerateOptionData {
      super.writeByte(142)
      super.writeValue(value.toList())
    } else if let value = value as? RegisterGenerateOptionExcludeCredential {
      super.writeByte(143)
      super.writeValue(value.toList())
    } else if let value = value as? RegisterGenerateOptionRp {
      super.writeByte(144)
      super.writeValue(value.toList())
    } else if let value = value as? RegisterGenerateOptionUser {
      super.writeByte(145)
      super.writeValue(value.toList())
    } else if let value = value as? RegisterGenerateOptionPublicKeyParams {
      super.writeByte(146)
      super.writeValue(value.toList())
    } else if let value = value as? RegisterGenerateOptionAuthenticatorSelection {
      super.writeByte(147)
      super.writeValue(value.toList())
    } else if let value = value as? RegisterGenerateOptionExtension {
      super.writeByte(148)
      super.writeValue(value.toList())
    } else if let value = value as? RegisterVerifyResponse {
      super.writeByte(149)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class MessagesPigeonCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return MessagesPigeonCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return MessagesPigeonCodecWriter(data: data)
  }
}

class MessagesPigeonCodec: FlutterStandardMessageCodec, @unchecked Sendable {
  static let shared = MessagesPigeonCodec(readerWriter: MessagesPigeonCodecReaderWriter())
}


/// Host API for passkey operations from Flutter to native platforms
///
/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol PasskeyHostApi {
  /// Registers a new passkey credential
  func register(options: RegisterGenerateOptionData, completion: @escaping (Result<CreatePasskeyResponseData, Error>) -> Void)
  /// Authenticates with an existing passkey
  func authenticate(request: AuthGenerateOptionResponseData, completion: @escaping (Result<GetPasskeyAuthenticationResponseData, Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class PasskeyHostApiSetup {
  static var codec: FlutterStandardMessageCodec { MessagesPigeonCodec.shared }
  /// Sets up an instance of `PasskeyHostApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: PasskeyHostApi?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    /// Registers a new passkey credential
    let registerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_passkey_service.PasskeyHostApi.register\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      registerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let optionsArg = args[0] as! RegisterGenerateOptionData
        api.register(options: optionsArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      registerChannel.setMessageHandler(nil)
    }
    /// Authenticates with an existing passkey
    let authenticateChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.flutter_passkey_service.PasskeyHostApi.authenticate\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      authenticateChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let requestArg = args[0] as! AuthGenerateOptionResponseData
        api.authenticate(request: requestArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      authenticateChannel.setMessageHandler(nil)
    }
  }
}
