// Autogenerated from Pigeon (v26.0.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import, no_leading_underscores_for_local_identifiers

import 'dart:async';
import 'dart:typed_data' show Float64List, Int32List, Int64List, Uint8List;

import 'package:flutter/foundation.dart' show ReadBuffer, WriteBuffer;
import 'package:flutter/services.dart';

PlatformException _createConnectionError(String channelName) {
  return PlatformException(
    code: 'channel-error',
    message: 'Unable to establish connection on channel: "$channelName".',
  );
}

bool _deepEquals(Object? a, Object? b) {
  if (a is List && b is List) {
    return a.length == b.length &&
        a.indexed.every(
          ((int, dynamic) item) => _deepEquals(item.$2, b[item.$1]),
        );
  }
  if (a is Map && b is Map) {
    return a.length == b.length &&
        a.entries.every(
          (MapEntry<Object?, Object?> entry) =>
              (b as Map<Object?, Object?>).containsKey(entry.key) &&
              _deepEquals(entry.value, b[entry.key]),
        );
  }
  return a == b;
}

/// Predefined error types for consistent error handling across platforms
enum PasskeyErrorType {
  invalidParameters,
  missingRequiredField,
  invalidFormat,
  decodingChallenge,
  userCancelled,
  userTimeout,
  userOptedOut,
  insufficientPermissions,
  securityViolation,
  notAllowed,
  domainNotAssociated,
  noCredentialsAvailable,
  credentialNotFound,
  invalidCredential,
  credentialAlreadyExists,
  invalidResponse,
  notHandled,
  failed,
  platformNotSupported,
  operationNotSupported,
  systemError,
  networkError,
  domError,
  webauthnError,
  attestationError,
  excludeCredentialsMatch,
  unexpectedAuthorizationResponse,
  wkErrorDomain,
  unknownError,
  unexpectedError,
}

/// Represents a standardized passkey exception that can be thrown across platforms
class PasskeyException {
  PasskeyException({
    required this.errorType,
    required this.message,
    required this.details,
  });

  /// Error type identifying the specific type of error
  PasskeyErrorType errorType;

  /// Error message describing what went wrong
  String message;

  /// Optional additional details about the error
  String details;

  List<Object?> _toList() {
    return <Object?>[errorType, message, details];
  }

  Object encode() {
    return _toList();
  }

  static PasskeyException decode(Object result) {
    result as List<Object?>;
    return PasskeyException(
      errorType: result[0]! as PasskeyErrorType,
      message: result[1]! as String,
      details: result[2]! as String,
    );
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (other is! PasskeyException || other.runtimeType != runtimeType) {
      return false;
    }
    if (identical(this, other)) {
      return true;
    }
    return _deepEquals(encode(), other.encode());
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hashAll(_toList());
}

/// Represents the response data for authentication generation options
class AuthGenerateOptionResponseData {
  AuthGenerateOptionResponseData({
    required this.rpId,
    required this.challenge,
    required this.allowCredentials,
    required this.timeout,
    required this.userVerification,
  });

  /// The relying party identifier
  String rpId;

  /// The challenge string
  String challenge;

  /// List of allowed credentials
  List<AuthGenerateOptionAllowCredential> allowCredentials;

  /// Timeout value in milliseconds
  int timeout;

  /// User verification requirement
  String userVerification;

  List<Object?> _toList() {
    return <Object?>[
      rpId,
      challenge,
      allowCredentials,
      timeout,
      userVerification,
    ];
  }

  Object encode() {
    return _toList();
  }

  static AuthGenerateOptionResponseData decode(Object result) {
    result as List<Object?>;
    return AuthGenerateOptionResponseData(
      rpId: result[0]! as String,
      challenge: result[1]! as String,
      allowCredentials: (result[2] as List<Object?>?)!
          .cast<AuthGenerateOptionAllowCredential>(),
      timeout: result[3]! as int,
      userVerification: result[4]! as String,
    );
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (other is! AuthGenerateOptionResponseData ||
        other.runtimeType != runtimeType) {
      return false;
    }
    if (identical(this, other)) {
      return true;
    }
    return _deepEquals(encode(), other.encode());
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hashAll(_toList());
}

/// Represents an allowed credential for authentication
class AuthGenerateOptionAllowCredential {
  AuthGenerateOptionAllowCredential({
    required this.id,
    required this.type,
    required this.transports,
  });

  /// The credential identifier
  String id;

  /// The credential type
  String type;

  /// List of transport methods
  List<String> transports;

  List<Object?> _toList() {
    return <Object?>[id, type, transports];
  }

  Object encode() {
    return _toList();
  }

  static AuthGenerateOptionAllowCredential decode(Object result) {
    result as List<Object?>;
    return AuthGenerateOptionAllowCredential(
      id: result[0]! as String,
      type: result[1]! as String,
      transports: (result[2] as List<Object?>?)!.cast<String>(),
    );
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (other is! AuthGenerateOptionAllowCredential ||
        other.runtimeType != runtimeType) {
      return false;
    }
    if (identical(this, other)) {
      return true;
    }
    return _deepEquals(encode(), other.encode());
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hashAll(_toList());
}

/// Represents the response data for authentication verification
class AuthVerifyResponse {
  AuthVerifyResponse({
    this.verified = false,
    this.accessToken = '',
    this.user,
    required this.refreshToken,
  });

  /// Whether the authentication was verified
  bool verified;

  /// Access token for authenticated session
  String accessToken;

  /// User information (optional)
  User? user;

  /// Refresh token for session renewal
  String refreshToken;

  List<Object?> _toList() {
    return <Object?>[verified, accessToken, user, refreshToken];
  }

  Object encode() {
    return _toList();
  }

  static AuthVerifyResponse decode(Object result) {
    result as List<Object?>;
    return AuthVerifyResponse(
      verified: result[0]! as bool,
      accessToken: result[1]! as String,
      user: result[2] as User?,
      refreshToken: result[3]! as String,
    );
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (other is! AuthVerifyResponse || other.runtimeType != runtimeType) {
      return false;
    }
    if (identical(this, other)) {
      return true;
    }
    return _deepEquals(encode(), other.encode());
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hashAll(_toList());
}

/// Represents user information
class User {
  User({this.id = '', this.username = '', this.phone, this.email});

  /// User identifier
  String id;

  /// Username
  String username;

  /// Phone number (optional)
  String? phone;

  /// Email address (optional)
  String? email;

  List<Object?> _toList() {
    return <Object?>[id, username, phone, email];
  }

  Object encode() {
    return _toList();
  }

  static User decode(Object result) {
    result as List<Object?>;
    return User(
      id: result[0]! as String,
      username: result[1]! as String,
      phone: result[2] as String?,
      email: result[3] as String?,
    );
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (other is! User || other.runtimeType != runtimeType) {
      return false;
    }
    if (identical(this, other)) {
      return true;
    }
    return _deepEquals(encode(), other.encode());
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hashAll(_toList());
}

/// Represents the response data for creating a passkey
class CreatePasskeyResponseData {
  CreatePasskeyResponseData({
    required this.rawId,
    required this.authenticatorAttachment,
    required this.type,
    required this.id,
    required this.response,
    required this.clientExtensionResults,
    this.username = 'username',
  });

  /// Raw identifier
  String rawId;

  /// Authenticator attachment type
  String authenticatorAttachment;

  /// Type of credential
  String type;

  /// Credential identifier
  String id;

  /// Response data from passkey creation
  CreatePasskeyResponse response;

  /// Client extension results
  CreatePasskeyExtension clientExtensionResults;

  /// Username associated with the passkey
  String username;

  List<Object?> _toList() {
    return <Object?>[
      rawId,
      authenticatorAttachment,
      type,
      id,
      response,
      clientExtensionResults,
      username,
    ];
  }

  Object encode() {
    return _toList();
  }

  static CreatePasskeyResponseData decode(Object result) {
    result as List<Object?>;
    return CreatePasskeyResponseData(
      rawId: result[0]! as String,
      authenticatorAttachment: result[1]! as String,
      type: result[2]! as String,
      id: result[3]! as String,
      response: result[4]! as CreatePasskeyResponse,
      clientExtensionResults: result[5]! as CreatePasskeyExtension,
      username: result[6]! as String,
    );
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (other is! CreatePasskeyResponseData ||
        other.runtimeType != runtimeType) {
      return false;
    }
    if (identical(this, other)) {
      return true;
    }
    return _deepEquals(encode(), other.encode());
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hashAll(_toList());
}

/// Represents the response from passkey creation
class CreatePasskeyResponse {
  CreatePasskeyResponse({
    required this.clientDataJSON,
    required this.attestationObject,
    required this.transports,
    required this.authenticatorData,
    required this.publicKeyAlgorithm,
    required this.publicKey,
  });

  /// Client data JSON
  String clientDataJSON;

  /// Attestation object
  String attestationObject;

  /// List of transport methods
  List<String> transports;

  /// Authenticator data
  String authenticatorData;

  /// Public key algorithm identifier
  int publicKeyAlgorithm;

  /// Public key
  String publicKey;

  List<Object?> _toList() {
    return <Object?>[
      clientDataJSON,
      attestationObject,
      transports,
      authenticatorData,
      publicKeyAlgorithm,
      publicKey,
    ];
  }

  Object encode() {
    return _toList();
  }

  static CreatePasskeyResponse decode(Object result) {
    result as List<Object?>;
    return CreatePasskeyResponse(
      clientDataJSON: result[0]! as String,
      attestationObject: result[1]! as String,
      transports: (result[2] as List<Object?>?)!.cast<String>(),
      authenticatorData: result[3]! as String,
      publicKeyAlgorithm: result[4]! as int,
      publicKey: result[5]! as String,
    );
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (other is! CreatePasskeyResponse || other.runtimeType != runtimeType) {
      return false;
    }
    if (identical(this, other)) {
      return true;
    }
    return _deepEquals(encode(), other.encode());
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hashAll(_toList());
}

/// Represents client extension results for passkey creation
class CreatePasskeyExtension {
  CreatePasskeyExtension({this.credProps, this.prf});

  /// Credential properties extension (optional)
  CreatePasskeyExtensionProps? credProps;

  /// PRF extension (optional)
  CreatePasskeyExtensionPrf? prf;

  List<Object?> _toList() {
    return <Object?>[credProps, prf];
  }

  Object encode() {
    return _toList();
  }

  static CreatePasskeyExtension decode(Object result) {
    result as List<Object?>;
    return CreatePasskeyExtension(
      credProps: result[0] as CreatePasskeyExtensionProps?,
      prf: result[1] as CreatePasskeyExtensionPrf?,
    );
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (other is! CreatePasskeyExtension || other.runtimeType != runtimeType) {
      return false;
    }
    if (identical(this, other)) {
      return true;
    }
    return _deepEquals(encode(), other.encode());
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hashAll(_toList());
}

/// Represents PRF extension properties
class CreatePasskeyExtensionPrf {
  CreatePasskeyExtensionPrf({required this.rk});

  /// Enabled flag
  bool rk;

  List<Object?> _toList() {
    return <Object?>[rk];
  }

  Object encode() {
    return _toList();
  }

  static CreatePasskeyExtensionPrf decode(Object result) {
    result as List<Object?>;
    return CreatePasskeyExtensionPrf(rk: result[0]! as bool);
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (other is! CreatePasskeyExtensionPrf ||
        other.runtimeType != runtimeType) {
      return false;
    }
    if (identical(this, other)) {
      return true;
    }
    return _deepEquals(encode(), other.encode());
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hashAll(_toList());
}

/// Represents credential properties extension
class CreatePasskeyExtensionProps {
  CreatePasskeyExtensionProps({required this.rk});

  /// Resident key flag
  bool rk;

  List<Object?> _toList() {
    return <Object?>[rk];
  }

  Object encode() {
    return _toList();
  }

  static CreatePasskeyExtensionProps decode(Object result) {
    result as List<Object?>;
    return CreatePasskeyExtensionProps(rk: result[0]! as bool);
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (other is! CreatePasskeyExtensionProps ||
        other.runtimeType != runtimeType) {
      return false;
    }
    if (identical(this, other)) {
      return true;
    }
    return _deepEquals(encode(), other.encode());
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hashAll(_toList());
}

/// Represents the response data for passkey authentication
class GetPasskeyAuthenticationResponseData {
  GetPasskeyAuthenticationResponseData({
    required this.authenticatorAttachment,
    required this.id,
    required this.rawId,
    required this.response,
    required this.type,
    this.username = 'username',
  });

  /// Authenticator attachment type
  String authenticatorAttachment;

  /// Credential identifier
  String id;

  /// Raw identifier
  String rawId;

  /// Authentication response data
  GetPasskeyAuthenticationResponse response;

  /// Type of credential
  String type;

  /// Username associated with the passkey
  String username;

  List<Object?> _toList() {
    return <Object?>[
      authenticatorAttachment,
      id,
      rawId,
      response,
      type,
      username,
    ];
  }

  Object encode() {
    return _toList();
  }

  static GetPasskeyAuthenticationResponseData decode(Object result) {
    result as List<Object?>;
    return GetPasskeyAuthenticationResponseData(
      authenticatorAttachment: result[0]! as String,
      id: result[1]! as String,
      rawId: result[2]! as String,
      response: result[3]! as GetPasskeyAuthenticationResponse,
      type: result[4]! as String,
      username: result[5]! as String,
    );
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (other is! GetPasskeyAuthenticationResponseData ||
        other.runtimeType != runtimeType) {
      return false;
    }
    if (identical(this, other)) {
      return true;
    }
    return _deepEquals(encode(), other.encode());
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hashAll(_toList());
}

/// Represents the authentication response from passkey
class GetPasskeyAuthenticationResponse {
  GetPasskeyAuthenticationResponse({
    required this.clientDataJSON,
    required this.authenticatorData,
    required this.signature,
    required this.userHandle,
  });

  /// Client data JSON
  String clientDataJSON;

  /// Authenticator data
  String authenticatorData;

  /// Digital signature
  String signature;

  /// User handle
  String userHandle;

  List<Object?> _toList() {
    return <Object?>[clientDataJSON, authenticatorData, signature, userHandle];
  }

  Object encode() {
    return _toList();
  }

  static GetPasskeyAuthenticationResponse decode(Object result) {
    result as List<Object?>;
    return GetPasskeyAuthenticationResponse(
      clientDataJSON: result[0]! as String,
      authenticatorData: result[1]! as String,
      signature: result[2]! as String,
      userHandle: result[3]! as String,
    );
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (other is! GetPasskeyAuthenticationResponse ||
        other.runtimeType != runtimeType) {
      return false;
    }
    if (identical(this, other)) {
      return true;
    }
    return _deepEquals(encode(), other.encode());
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hashAll(_toList());
}

/// Represents the data for generating registration options
class RegisterGenerateOptionData {
  RegisterGenerateOptionData({
    required this.challenge,
    required this.rp,
    required this.user,
    required this.pubKeyCredParams,
    required this.timeout,
    required this.attestation,
    required this.excludeCredentials,
    required this.authenticatorSelection,
    required this.extensions,
  });

  /// Challenge string
  String challenge;

  /// Relying party information
  RegisterGenerateOptionRp rp;

  /// User information
  RegisterGenerateOptionUser user;

  /// Public key credential parameters
  List<RegisterGenerateOptionPublicKeyParams> pubKeyCredParams;

  /// Timeout value in milliseconds
  int timeout;

  /// Attestation preference
  String attestation;

  /// Credentials to exclude from registration
  List<RegisterGenerateOptionExcludeCredential> excludeCredentials;

  /// Authenticator selection criteria
  RegisterGenerateOptionAuthenticatorSelection authenticatorSelection;

  /// Extensions for registration
  RegisterGenerateOptionExtension extensions;

  List<Object?> _toList() {
    return <Object?>[
      challenge,
      rp,
      user,
      pubKeyCredParams,
      timeout,
      attestation,
      excludeCredentials,
      authenticatorSelection,
      extensions,
    ];
  }

  Object encode() {
    return _toList();
  }

  static RegisterGenerateOptionData decode(Object result) {
    result as List<Object?>;
    return RegisterGenerateOptionData(
      challenge: result[0]! as String,
      rp: result[1]! as RegisterGenerateOptionRp,
      user: result[2]! as RegisterGenerateOptionUser,
      pubKeyCredParams: (result[3] as List<Object?>?)!
          .cast<RegisterGenerateOptionPublicKeyParams>(),
      timeout: result[4]! as int,
      attestation: result[5]! as String,
      excludeCredentials: (result[6] as List<Object?>?)!
          .cast<RegisterGenerateOptionExcludeCredential>(),
      authenticatorSelection:
          result[7]! as RegisterGenerateOptionAuthenticatorSelection,
      extensions: result[8]! as RegisterGenerateOptionExtension,
    );
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (other is! RegisterGenerateOptionData ||
        other.runtimeType != runtimeType) {
      return false;
    }
    if (identical(this, other)) {
      return true;
    }
    return _deepEquals(encode(), other.encode());
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hashAll(_toList());
}

/// Represents a credential to exclude from registration
class RegisterGenerateOptionExcludeCredential {
  RegisterGenerateOptionExcludeCredential({
    required this.id,
    required this.type,
    required this.transports,
  });

  /// Credential identifier
  String id;

  /// Credential type
  String type;

  /// List of transport methods
  List<String> transports;

  List<Object?> _toList() {
    return <Object?>[id, type, transports];
  }

  Object encode() {
    return _toList();
  }

  static RegisterGenerateOptionExcludeCredential decode(Object result) {
    result as List<Object?>;
    return RegisterGenerateOptionExcludeCredential(
      id: result[0]! as String,
      type: result[1]! as String,
      transports: (result[2] as List<Object?>?)!.cast<String>(),
    );
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (other is! RegisterGenerateOptionExcludeCredential ||
        other.runtimeType != runtimeType) {
      return false;
    }
    if (identical(this, other)) {
      return true;
    }
    return _deepEquals(encode(), other.encode());
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hashAll(_toList());
}

/// Represents relying party information for registration
class RegisterGenerateOptionRp {
  RegisterGenerateOptionRp({required this.name, required this.id});

  /// Relying party name
  String name;

  /// Relying party identifier
  String id;

  List<Object?> _toList() {
    return <Object?>[name, id];
  }

  Object encode() {
    return _toList();
  }

  static RegisterGenerateOptionRp decode(Object result) {
    result as List<Object?>;
    return RegisterGenerateOptionRp(
      name: result[0]! as String,
      id: result[1]! as String,
    );
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (other is! RegisterGenerateOptionRp ||
        other.runtimeType != runtimeType) {
      return false;
    }
    if (identical(this, other)) {
      return true;
    }
    return _deepEquals(encode(), other.encode());
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hashAll(_toList());
}

/// Represents user information for registration
class RegisterGenerateOptionUser {
  RegisterGenerateOptionUser({
    required this.id,
    required this.name,
    this.displayName = '',
  });

  /// User identifier
  String id;

  /// User name
  String name;

  /// Display name (defaults to empty string)
  String displayName;

  List<Object?> _toList() {
    return <Object?>[id, name, displayName];
  }

  Object encode() {
    return _toList();
  }

  static RegisterGenerateOptionUser decode(Object result) {
    result as List<Object?>;
    return RegisterGenerateOptionUser(
      id: result[0]! as String,
      name: result[1]! as String,
      displayName: result[2]! as String,
    );
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (other is! RegisterGenerateOptionUser ||
        other.runtimeType != runtimeType) {
      return false;
    }
    if (identical(this, other)) {
      return true;
    }
    return _deepEquals(encode(), other.encode());
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hashAll(_toList());
}

/// Represents public key credential parameters
class RegisterGenerateOptionPublicKeyParams {
  RegisterGenerateOptionPublicKeyParams({
    required this.alg,
    required this.type,
  });

  /// Algorithm identifier
  int alg;

  /// Credential type
  String type;

  List<Object?> _toList() {
    return <Object?>[alg, type];
  }

  Object encode() {
    return _toList();
  }

  static RegisterGenerateOptionPublicKeyParams decode(Object result) {
    result as List<Object?>;
    return RegisterGenerateOptionPublicKeyParams(
      alg: result[0]! as int,
      type: result[1]! as String,
    );
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (other is! RegisterGenerateOptionPublicKeyParams ||
        other.runtimeType != runtimeType) {
      return false;
    }
    if (identical(this, other)) {
      return true;
    }
    return _deepEquals(encode(), other.encode());
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hashAll(_toList());
}

/// Represents authenticator selection criteria
class RegisterGenerateOptionAuthenticatorSelection {
  RegisterGenerateOptionAuthenticatorSelection({
    required this.residentKey,
    required this.userVerification,
    required this.requireResidentKey,
    this.authenticatorAttachment = 'platform',
  });

  /// Resident key requirement
  String residentKey;

  /// User verification requirement
  String userVerification;

  /// Whether resident key is required
  bool requireResidentKey;

  /// Authenticator attachment preference
  String authenticatorAttachment;

  List<Object?> _toList() {
    return <Object?>[
      residentKey,
      userVerification,
      requireResidentKey,
      authenticatorAttachment,
    ];
  }

  Object encode() {
    return _toList();
  }

  static RegisterGenerateOptionAuthenticatorSelection decode(Object result) {
    result as List<Object?>;
    return RegisterGenerateOptionAuthenticatorSelection(
      residentKey: result[0]! as String,
      userVerification: result[1]! as String,
      requireResidentKey: result[2]! as bool,
      authenticatorAttachment: result[3]! as String,
    );
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (other is! RegisterGenerateOptionAuthenticatorSelection ||
        other.runtimeType != runtimeType) {
      return false;
    }
    if (identical(this, other)) {
      return true;
    }
    return _deepEquals(encode(), other.encode());
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hashAll(_toList());
}

/// Represents extensions for registration
class RegisterGenerateOptionExtension {
  RegisterGenerateOptionExtension({required this.credProps});

  /// Credential properties extension
  bool credProps;

  List<Object?> _toList() {
    return <Object?>[credProps];
  }

  Object encode() {
    return _toList();
  }

  static RegisterGenerateOptionExtension decode(Object result) {
    result as List<Object?>;
    return RegisterGenerateOptionExtension(credProps: result[0]! as bool);
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (other is! RegisterGenerateOptionExtension ||
        other.runtimeType != runtimeType) {
      return false;
    }
    if (identical(this, other)) {
      return true;
    }
    return _deepEquals(encode(), other.encode());
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hashAll(_toList());
}

/// Represents the response data for registration verification
class RegisterVerifyResponse {
  RegisterVerifyResponse({
    required this.verified,
    this.accessToken = '',
    required this.user,
    required this.refreshToken,
  });

  /// Whether the registration was verified
  bool verified;

  /// Access token for authenticated session
  String accessToken;

  /// User information
  User user;

  /// Refresh token for session renewal
  String refreshToken;

  List<Object?> _toList() {
    return <Object?>[verified, accessToken, user, refreshToken];
  }

  Object encode() {
    return _toList();
  }

  static RegisterVerifyResponse decode(Object result) {
    result as List<Object?>;
    return RegisterVerifyResponse(
      verified: result[0]! as bool,
      accessToken: result[1]! as String,
      user: result[2]! as User,
      refreshToken: result[3]! as String,
    );
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  bool operator ==(Object other) {
    if (other is! RegisterVerifyResponse || other.runtimeType != runtimeType) {
      return false;
    }
    if (identical(this, other)) {
      return true;
    }
    return _deepEquals(encode(), other.encode());
  }

  @override
  // ignore: avoid_equals_and_hash_code_on_mutable_classes
  int get hashCode => Object.hashAll(_toList());
}

class _PigeonCodec extends StandardMessageCodec {
  const _PigeonCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is int) {
      buffer.putUint8(4);
      buffer.putInt64(value);
    } else if (value is PasskeyErrorType) {
      buffer.putUint8(129);
      writeValue(buffer, value.index);
    } else if (value is PasskeyException) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else if (value is AuthGenerateOptionResponseData) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else if (value is AuthGenerateOptionAllowCredential) {
      buffer.putUint8(132);
      writeValue(buffer, value.encode());
    } else if (value is AuthVerifyResponse) {
      buffer.putUint8(133);
      writeValue(buffer, value.encode());
    } else if (value is User) {
      buffer.putUint8(134);
      writeValue(buffer, value.encode());
    } else if (value is CreatePasskeyResponseData) {
      buffer.putUint8(135);
      writeValue(buffer, value.encode());
    } else if (value is CreatePasskeyResponse) {
      buffer.putUint8(136);
      writeValue(buffer, value.encode());
    } else if (value is CreatePasskeyExtension) {
      buffer.putUint8(137);
      writeValue(buffer, value.encode());
    } else if (value is CreatePasskeyExtensionPrf) {
      buffer.putUint8(138);
      writeValue(buffer, value.encode());
    } else if (value is CreatePasskeyExtensionProps) {
      buffer.putUint8(139);
      writeValue(buffer, value.encode());
    } else if (value is GetPasskeyAuthenticationResponseData) {
      buffer.putUint8(140);
      writeValue(buffer, value.encode());
    } else if (value is GetPasskeyAuthenticationResponse) {
      buffer.putUint8(141);
      writeValue(buffer, value.encode());
    } else if (value is RegisterGenerateOptionData) {
      buffer.putUint8(142);
      writeValue(buffer, value.encode());
    } else if (value is RegisterGenerateOptionExcludeCredential) {
      buffer.putUint8(143);
      writeValue(buffer, value.encode());
    } else if (value is RegisterGenerateOptionRp) {
      buffer.putUint8(144);
      writeValue(buffer, value.encode());
    } else if (value is RegisterGenerateOptionUser) {
      buffer.putUint8(145);
      writeValue(buffer, value.encode());
    } else if (value is RegisterGenerateOptionPublicKeyParams) {
      buffer.putUint8(146);
      writeValue(buffer, value.encode());
    } else if (value is RegisterGenerateOptionAuthenticatorSelection) {
      buffer.putUint8(147);
      writeValue(buffer, value.encode());
    } else if (value is RegisterGenerateOptionExtension) {
      buffer.putUint8(148);
      writeValue(buffer, value.encode());
    } else if (value is RegisterVerifyResponse) {
      buffer.putUint8(149);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 129:
        final int? value = readValue(buffer) as int?;
        return value == null ? null : PasskeyErrorType.values[value];
      case 130:
        return PasskeyException.decode(readValue(buffer)!);
      case 131:
        return AuthGenerateOptionResponseData.decode(readValue(buffer)!);
      case 132:
        return AuthGenerateOptionAllowCredential.decode(readValue(buffer)!);
      case 133:
        return AuthVerifyResponse.decode(readValue(buffer)!);
      case 134:
        return User.decode(readValue(buffer)!);
      case 135:
        return CreatePasskeyResponseData.decode(readValue(buffer)!);
      case 136:
        return CreatePasskeyResponse.decode(readValue(buffer)!);
      case 137:
        return CreatePasskeyExtension.decode(readValue(buffer)!);
      case 138:
        return CreatePasskeyExtensionPrf.decode(readValue(buffer)!);
      case 139:
        return CreatePasskeyExtensionProps.decode(readValue(buffer)!);
      case 140:
        return GetPasskeyAuthenticationResponseData.decode(readValue(buffer)!);
      case 141:
        return GetPasskeyAuthenticationResponse.decode(readValue(buffer)!);
      case 142:
        return RegisterGenerateOptionData.decode(readValue(buffer)!);
      case 143:
        return RegisterGenerateOptionExcludeCredential.decode(
          readValue(buffer)!,
        );
      case 144:
        return RegisterGenerateOptionRp.decode(readValue(buffer)!);
      case 145:
        return RegisterGenerateOptionUser.decode(readValue(buffer)!);
      case 146:
        return RegisterGenerateOptionPublicKeyParams.decode(readValue(buffer)!);
      case 147:
        return RegisterGenerateOptionAuthenticatorSelection.decode(
          readValue(buffer)!,
        );
      case 148:
        return RegisterGenerateOptionExtension.decode(readValue(buffer)!);
      case 149:
        return RegisterVerifyResponse.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

/// Host API for passkey operations from Flutter to native platforms
class PasskeyHostApi {
  /// Constructor for [PasskeyHostApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  PasskeyHostApi({
    BinaryMessenger? binaryMessenger,
    String messageChannelSuffix = '',
  }) : pigeonVar_binaryMessenger = binaryMessenger,
       pigeonVar_messageChannelSuffix = messageChannelSuffix.isNotEmpty
           ? '.$messageChannelSuffix'
           : '';
  final BinaryMessenger? pigeonVar_binaryMessenger;

  static const MessageCodec<Object?> pigeonChannelCodec = _PigeonCodec();

  final String pigeonVar_messageChannelSuffix;

  /// Registers a new passkey credential
  Future<CreatePasskeyResponseData> register(
    RegisterGenerateOptionData options,
  ) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.flutter_passkey_service.PasskeyHostApi.register$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
          pigeonVar_channelName,
          pigeonChannelCodec,
          binaryMessenger: pigeonVar_binaryMessenger,
        );
    final Future<Object?> pigeonVar_sendFuture = pigeonVar_channel.send(
      <Object?>[options],
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as CreatePasskeyResponseData?)!;
    }
  }

  /// Authenticates with an existing passkey
  Future<GetPasskeyAuthenticationResponseData> authenticate(
    AuthGenerateOptionResponseData request,
  ) async {
    final String pigeonVar_channelName =
        'dev.flutter.pigeon.flutter_passkey_service.PasskeyHostApi.authenticate$pigeonVar_messageChannelSuffix';
    final BasicMessageChannel<Object?> pigeonVar_channel =
        BasicMessageChannel<Object?>(
          pigeonVar_channelName,
          pigeonChannelCodec,
          binaryMessenger: pigeonVar_binaryMessenger,
        );
    final Future<Object?> pigeonVar_sendFuture = pigeonVar_channel.send(
      <Object?>[request],
    );
    final List<Object?>? pigeonVar_replyList =
        await pigeonVar_sendFuture as List<Object?>?;
    if (pigeonVar_replyList == null) {
      throw _createConnectionError(pigeonVar_channelName);
    } else if (pigeonVar_replyList.length > 1) {
      throw PlatformException(
        code: pigeonVar_replyList[0]! as String,
        message: pigeonVar_replyList[1] as String?,
        details: pigeonVar_replyList[2],
      );
    } else if (pigeonVar_replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (pigeonVar_replyList[0] as GetPasskeyAuthenticationResponseData?)!;
    }
  }
}
